-- Program to test parser, automatically generated by BNF Converter.

module Main where

import Control.Monad.Except (runExceptT, throwError)
import Control.Monad.RWS.Class (ask, get)
import Control.Monad.Reader (runReaderT)
import Control.Monad.State.Lazy (runStateT)
import Data.Foldable as F
import Data.Map as M
import Grammar.Abs
import Grammar.ErrM
import Grammar.Par (myLexer, pProgram)
import Grammar.Skel ()
import Processor.Evaluate
import Processor.EvaluateStmt
import System.Environment (getArgs)
import System.Exit (exitFailure)

-- run program

accumulate :: Result (Result () -> Result ()) -> Result () -> Result ()
accumulate declCont currentRes = do
  f <- declCont
  f currentRes

declare :: TopDef -> Result (Result () -> Result ())
declare topDef = do
  mainEnv <- ask
  case topDef of
    GlobDecl t items -> declareValues (declareIdents items) (initItems items t)
    GlobFinDecl t items -> declareValues (declareIdents items) (initItems items t)
    FnDef _ ident _ _ -> declareValue ident (return $ VFun topDef mainEnv)

setGlobEnvInValues :: (Addr, Value) -> Result ()
setGlobEnvInValues (addr, value) = do
  globalEnv <- ask
  case value of
    (VFun f _) -> updateMem (M.insert addr (VFun f globalEnv))
    _ -> updateMem id

setGlobalEnv :: Result ()
setGlobalEnv = do
  (mem, _, _) <- get
  F.mapM_ setGlobEnvInValues (M.toList mem)

-- Configures the global environment of the program
-- Calls the main function if it is found
config :: Result ()
config = do
  setGlobalEnv
  globEnv <- ask
  let mainFun = Ident "main"
  case M.lookup mainFun globEnv of
    Nothing -> throwError "No definition for `main` function"
    Just addr -> do
      result <- getValueByAddr addr
      case result of
        (VFun mainF _) -> do
          _ <- evalMain mainF globEnv
          return ()
        _ -> throwError "Unknown Exception"

run :: Program -> Result ()
run (Program topDefs) =
  -- Starts at the rightmost part of topDefs and combines each Result with config
  -- by declaring and accumulating with config
  F.foldr (accumulate . declare) config topDefs

-- Evaluates the program
-- Print runtime error message if program is not correct
runIO :: Program -> IO ()
runIO p = do
  result <- runExceptT (runStateT (runReaderT (run p) M.empty) (M.empty, 0, 0))
  case result of
    Bad msg -> putStrLn $ "Runtime error: " ++ msg
    _ -> return ()

-- end run program

-- In case no input file is provided
usage :: IO ()
usage = do
  putStrLn "Expecting input file as argument..."
  exitFailure

-- Get input filename and read the content
getInput :: [String] -> Maybe (IO String)
getInput [] = Nothing
getInput (fileName : _) = return $ readFile fileName

-- Get input file and execute
-- Show usage if no input file found
-- Parse the program and get AST
-- Evaluate the tree
main :: IO ()
main = do
  args <- getArgs
  case getInput args of
    Nothing -> usage
    Just content -> do
      input <- content
      case pProgram $ myLexer input of
        Bad msg -> do
          -- In case parsing failed
          putStrLn "\nParse              Failed...\n"
          putStrLn "Tokens:"
          putStrLn msg
          exitFailure
        Ok t -> do
          -- Execute the program
          runIO t
